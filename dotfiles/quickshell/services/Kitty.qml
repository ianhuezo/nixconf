pragma Singleton
import Quickshell
import Quickshell.Io
import QtQuick

Singleton {
    id: root

    property var kittySockets: []
    property bool findingSocketsInProgress: false
    property bool updatingColors: false

    // Helper function to get hex string from QML color (returns format like "#rrggbb")
    function colorToHex(color) {
        return color.toString();
    }

    // Watch /tmp directory for new kitty sockets using inotify
    Process {
        id: socketWatcher
        command: ["sh", "-c", "inotifywait -m -e create -e moved_to /tmp 2>/dev/null | grep --line-buffered 'kitty-'"]
        running: true

        stdout: SplitParser {
            onRead: data => {
                // inotifywait output: /tmp/ CREATE kitty-12345
                // Extract the socket name
                let match = data.match(/kitty-\d+/);
                if (match) {
                    let socketPath = "/tmp/" + match[0];
                    console.log("New Kitty instance detected:", socketPath);

                    // Add to our list
                    if (!root.kittySockets.includes(socketPath)) {
                        root.kittySockets.push(socketPath);
                    }

                    // Apply colors to the new instance
                    updateKittyInstance(socketPath, 0);
                }
            }
        }
    }

    // Find all kitty sockets
    function findKittySockets() {
        if (!findingSocketsInProgress) {
            findingSocketsInProgress = true;
            socketFinder.running = true;
        }
    }

    Process {
        id: socketFinder
        command: ["sh", "-c", "ls /tmp/kitty-* 2>/dev/null"]
        running: false

        stdout: SplitParser {
            onRead: data => {
                let sockets = data.trim().split('\n').filter(s => s.length > 0);
                root.kittySockets = sockets;
                root.findingSocketsInProgress = false;
                // Now update colors
                root.doUpdateColors();
            }
        }

        onExited: (code, status) => {
            root.findingSocketsInProgress = false;
        }
    }

    // Update kitty colors using remote control
    function updateColors() {
        if (!Color.palette) {
            console.warn("Color palette not available");
            return;
        }

        if (updatingColors) {
            console.log("Already updating colors, skipping");
            return;
        }

        updatingColors = true;

        // Write current colors to file for shell integration hook
        writeCurrentColorsFile();

        // Find sockets and then update
        findKittySockets();
    }

    function doUpdateColors() {
        // Update each kitty instance
        for (let i = 0; i < kittySockets.length; i++) {
            updateKittyInstance(kittySockets[i], i);
        }

        // Also trigger a reload from the colors file for all kitty instances
        // This ensures even kitty instances with running programs get updated
        Qt.callLater(() => {
            for (let i = 0; i < kittySockets.length; i++) {
                reloadKittyColors(kittySockets[i]);
            }
            updatingColors = false;
        });
    }

    // Reload colors from the current-colors.conf file
    function reloadKittyColors(socketPath) {
        let cmd = ["kitty", "@", "--to", "unix:" + socketPath, "load-config"];

        let processQml = `
            import Quickshell
            import Quickshell.Io
            Process {
                property string socketPath: "${socketPath}"
                command: ${JSON.stringify(cmd)}
                running: true

                onExited: (code, status) => {
                    if (code === 0) {
                        console.log("Reloaded kitty config for:", socketPath);
                    }
                    destroy();
                }
            }
        `;

        Qt.createQmlObject(processQml, root, "kittyReload_" + socketPath.replace(/\//g, "_"));
    }

    // Write current colors to a file that can be sourced by kitty
    function writeCurrentColorsFile() {
        let colorConfig = `# Auto-generated by QuickShell
foreground ${colorToHex(Color.palette.base05)}
background ${colorToHex(Color.palette.base00)}
color0 ${colorToHex(Color.palette.base03)}
color8 ${colorToHex(Color.palette.base03)}
color1 ${colorToHex(Color.palette.base08)}
color9 ${colorToHex(Color.palette.base08)}
color2 ${colorToHex(Color.palette.base0C)}
color10 ${colorToHex(Color.palette.base0C)}
color3 ${colorToHex(Color.palette.base09)}
color11 ${colorToHex(Color.palette.base09)}
color4 ${colorToHex(Color.palette.base0D)}
color12 ${colorToHex(Color.palette.base0D)}
color5 ${colorToHex(Color.palette.base0E)}
color13 ${colorToHex(Color.palette.base0E)}
color6 ${colorToHex(Color.palette.base0C)}
color14 ${colorToHex(Color.palette.base0C)}
color7 ${colorToHex(Color.palette.base05)}
color15 ${colorToHex(Color.palette.base05)}
cursor ${colorToHex(Color.palette.base05)}
cursor_text_color ${colorToHex(Color.palette.base00)}
selection_foreground none
selection_background ${colorToHex(Color.palette.base03)}
url_color ${colorToHex(Color.palette.base0B)}
active_border_color ${colorToHex(Color.palette.base0D)}
inactive_border_color ${colorToHex(Color.palette.base00)}
bell_border_color ${colorToHex(Color.palette.base09)}
active_tab_foreground ${colorToHex(Color.palette.base0D)}
active_tab_background ${colorToHex(Color.palette.base00)}
inactive_tab_foreground ${colorToHex(Color.palette.base04)}
inactive_tab_background ${colorToHex(Color.palette.base00)}
tab_bar_background ${colorToHex(Color.palette.base00)}
`;

        let cmd = ["sh", "-c", "mkdir -p ~/.config/kitty && cat > ~/.config/kitty/current-colors.conf << 'KITTYEOF'\n" + colorConfig + "\nKITTYEOF"];

        let processQml = `
            import Quickshell
            import Quickshell.Io
            Process {
                command: ${JSON.stringify(cmd)}
                running: true

                onExited: (code, status) => {
                    if (code === 0) {
                        console.log("Successfully wrote kitty current-colors.conf");
                    } else {
                        console.error("Failed to write kitty current-colors.conf, exit code:", code);
                    }
                    destroy();
                }
            }
        `;

        Qt.createQmlObject(processQml, root, "writeKittyColors");
    }

    // Update a single kitty instance
    function updateKittyInstance(socketPath, index) {
        // Build the command arguments
        let args = ["@", "--to", "unix:" + socketPath, "set-colors",
            // Foreground and background
            "foreground=" + colorToHex(Color.palette.base05), "background=" + colorToHex(Color.palette.base00),

            // Grayscale colors (color0/color8)
            "color0=" + colorToHex(Color.palette.base03), "color8=" + colorToHex(Color.palette.base03),

            // Red/Salmon (color1/color9)
            "color1=" + colorToHex(Color.palette.base08), "color9=" + colorToHex(Color.palette.base08),

            // Green (color2/color10)
            "color2=" + colorToHex(Color.palette.base0C), "color10=" + colorToHex(Color.palette.base0C),

            // Yellow-brown (color3/color11)
            "color3=" + colorToHex(Color.palette.base09), "color11=" + colorToHex(Color.palette.base09),

            // Blue (color4/color12)
            "color4=" + colorToHex(Color.palette.base0D), "color12=" + colorToHex(Color.palette.base0D),

            // Magenta (color5/color13)
            "color5=" + colorToHex(Color.palette.base0E), "color13=" + colorToHex(Color.palette.base0E),

            // Cyan (color6/color14)
            "color6=" + colorToHex(Color.palette.base0C), "color14=" + colorToHex(Color.palette.base0C),

            // White (color7/color15)
            "color7=" + colorToHex(Color.palette.base05), "color15=" + colorToHex(Color.palette.base05),

            // Cursor
            "cursor=" + colorToHex(Color.palette.base05), "cursor_text_color=" + colorToHex(Color.palette.base00),

            // Selection
            "selection_foreground=none", "selection_background=" + colorToHex(Color.palette.base03),

            // URL color
            "url_color=" + colorToHex(Color.palette.base0B),

            // Window borders
            "active_border_color=" + colorToHex(Color.palette.base0D), "inactive_border_color=" + colorToHex(Color.palette.base00), "bell_border_color=" + colorToHex(Color.palette.base09),

            // Tab bar
            "active_tab_foreground=" + colorToHex(Color.palette.base0D), "active_tab_background=" + colorToHex(Color.palette.base00), "inactive_tab_foreground=" + colorToHex(Color.palette.base04), "inactive_tab_background=" + colorToHex(Color.palette.base00), "tab_bar_background=" + colorToHex(Color.palette.base00)];

        let fullCommand = ["kitty"].concat(args);

        // Create a new process for each socket using QML string
        let processQml = `
            import Quickshell
            import Quickshell.Io
            Process {
                property string socketPath: "${socketPath}"
                command: ${JSON.stringify(fullCommand)}
                running: true

                onExited: (code, status) => {
                    if (code !== 0) {
                        console.error("Failed to update kitty colors for:", socketPath, "Exit code:", code);
                    }
                    destroy();
                }
            }
        `;

        let processComponent = Qt.createQmlObject(processQml, root, "kittyProcess_" + index);
    }

    // Initialize colors on component load
    Component.onCompleted: {
        Qt.callLater(updateColors);
    }
}
